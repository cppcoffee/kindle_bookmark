- 这些问题有什么实际的好处。尽管如此，数学已经

- 回答：“我觉得在表面照射到光线的地方，还有一点白和黄。”美术老师的笑容仍然挂在脸上，对我说：“很好，还有其他颜色吗？”这回我花了更长时间去观察水果，“没有别的颜色了，就是只有这该死的橙色，我看到的只有橙色和不同深浅的橙色。” 美术老师探过身来，拿走我手中的画笔，开始修改我的画作。他一边画，一边向我解释着他在做什么：“球体会有一些地方是更亮的，我们可以用白色和黄色来上色。此外还有阴影，可以用红色、棕色和绿色。橙子也会在一侧投下影子，我们可以用灰色和蓝色来表现，然后再用上一些棕色和红褐色，把橙子的边缘和它的

- 有 I/O 或 CPU、内存方面的限制。 I/O限制

- 当我们挑选数据存储技术的时候，最重要的就是考虑它的成熟度。你可以解决编程语言或客户端框架上存在的限制，但无法解决数据丢失的问题。但从成熟度这一点看，关系型数据库应该是我们做出任何数据存储决定的默认选择。我们可以先用关系型数据库对问题进行建模，看看在碰壁之前我们可以走多远。如果很长时间都没有碰壁也不用惊讶，因为关系型数据库也是相当灵活的。

- 编程是一种让他人了解你想让电脑做什么的艺术。 ——Donald Knuth

- 创业和人是密不可分的，所以对代码来说，最重要的并不是运行得多快或者使用什么样的算法，而是它对使用它的人有什么样的影响。编写整洁的代码并不是为了理想主义，也不是因为有些书上说你必须这么做（即便不是本书），更不是因为空格比制表符更优美，而是因为作为程序员，你要把大部分时间花在理解和维护代码上，这只是为了让自己方便。

- 实现整洁代码的一些基本原则，包括代码布局、命名、不要重复自己（don't repeat yourself，DRY）、单一职责原则（single responsibility principle，SRP）、函数式编程、松耦合、高内聚、注释和重构。

- 尽管程序员喜欢讨论空格好还是制表符好、大括号应该放在哪里这些问题，但实际的选择并不是太重要，真正要紧的是在代码库中要保持一致。

- 每一个代码库都定义了自己的语言，它是由类名、方法名、变量名、函数名、包名、文件名和目录名组成的。如果代码布局是语法的话，代码中的名称就是单词，它们是你用来思考代码的言语。好的名称应该能回答所有的重要问题，应该精确、全面，能够揭示意图，并且遵循约定。

- 变量、函数或类的名称应该回答所有重要的问题。它应该告诉你它存在的原因、它是干什么的，以及如何使用。 ——Robert C. Martin，《整洁代码之道》

- 我们应该让名称需要多长就多长，可以回答代码是什么、为什么和怎么样的问题。

- 一定要想出一个好的词，哪怕查词典也可以。

- 计算机科学只有两件难事：缓存失效和命名 3。 ——Phil Karlton

- 每一个程序都有不同的错误处理需求，但是不应该是静静地吞下各种错误。 清晰的错误消息是整洁代码的主要特征。

- 避免重复是实现整洁代码最根本的原则之一。

- 重复不仅因为要多次实现相同的事情而浪费了时间，而且还妨碍了我们对代码的理解和维护。

- 特别当我们必须一次次地重复相同的过程，那么就需要实现一种自动化的过程；如果不只在一个地方有相同的逻辑，那么就需要实现抽象，以便共享单一的实现。

- 重新发明轮子是最常见和不必要的重复，只要有可能，就应该使用开源库去代替（

- 单一职责原则（single responsibility principle，SRP）规定了每一个类、函数和变量都应该只有一个单一的目的。

- 遵循单一职责原则会使设计出现许多短小的、简单的、独立的函数，每个函数都容易阅读、维护和测试。而且，我们还可以把这些函数中的几个组合在一起，创建具有更复杂行为的函数，这就是函数式编程的基本原理：使用函数和函数的组合作为应用程序的构建块。其中的关键就是用一种安全且容易组合的方式去设计函数。

- 在软件领域，两个模块相互之间的依赖程度称为耦合。如果无论什么时候更新一个模块，都不得不频繁地更新另一个模块，这些模块就是紧耦合的，这通常表明代码是脆弱而且难以维护的。

- 整洁的代码应该遵循依赖反转原则： 高级的模块不应该依赖于低级的模块，二者都应该依赖于抽象； 抽象不应该依赖于细节，细节应该依赖于抽象。

- 不要为糟糕的代码注释——重新写吧。 ——Brian W. Kernighan、P. J. Plauger，《编程格调》

- 我是“先做纯粹重构，再做纯粹扩展”的忠实信徒。我们要对代码进行整理，直到可以轻易地新增下一个功能，但它在行为上不会有任何改变。之后就可以再新增下一个功能，接着再重复整个过程。 ——Deam Thompson，Transarc 公司、Premier Health Exchange、Peak Strategy 和 Mspoke 联合创始人

- 如果你已经到了害怕修改代码的地步，就意味着你需要在编码实践上进行扩展，以适应增长的需要。应对不断增长的代码库和开发团队的最重要的四个编码实践是： 自动化测试； 代码分离； 代码评审； 文档。

- 因为测试通过并不能保证代码没有 bug。没有哪种形式的测试可以保证代码是没有 bug 的，这只不过是一个概率问题。我们可以通过学习编写高质量的测试，提高代码没有 bug 的可能性。

- 判断测试质量的一个方法就是计算自动化测试运行的时候，有百分之多少的生产代码被执行了。这一衡量尺度称为代码覆盖，大部分的编程语言都提供了可以自动计算代码覆盖百分比的工具，甚至还能显示出哪部分代码被覆盖了，哪部分代码没有被覆盖。

- 最好的解决办法就是将代码分离成多个“片段”。通过这种方式，我们可以一次只考虑一个片段，并可以放心忽略其他片段。这就是所谓的抽象。

- 信息隐藏意味着抽象应该比其背后的细节更加简单，就像脑海中的图像要比真正的水果更加简单。

- 效率上的缺失是由于复杂的项目无法被划分为完全可以独立完成的单独任务，所以在沟通和协调上总是存在开销。

- 从较高的层次看，可以实施的组织设计有两种类型：一种是传统的经理驱动等级结构，另一种则是尝试打造分布式组织。

- 大部分人对经理驱动法都比较熟悉，因为它是多数现代公司所使用的。其理念是将公司分解为若干小团队，每个团队都向一位经理报告并关注一个单独的任务（例如分为技术团队、销售团队和产品团队）。团队中的每个成员通常只需要和所在团队的其他成员协调，不需要和整个公司协调。当多个团队需要一起工作的时候，大部分协调都在经理们之间进行。由于每一名经理的直接下属的数量被控制在一定范围内，公司是按照经理逐层上报直至 CEO 的等级结构设计的。 在分层级的组织中，经理负责大部分的协调和决策。

- 层级组织也有一些缺点，部门之间的沟通容易变得困难，组织的多层级化也可能导致许多官僚主义方面的开销，从而降低了效率。经理也可能成为所有沟通和协调的瓶颈所在。报酬、名声和赞赏通常都和你所在的层级紧密关联，便也导致许多人痴狂地关注如何往上升，醉心于弄权而非做事。最终，高级别的经理，也就是被赖以信任进行最重要决定的人，通常都远离了实际工作，在最不合适的地方去做决定。

- 层级设计的另一种形式就是分布式组织（有时也称为扁平组织）。其理念是让员工针对每个任务自我组织，形成最有效率的结构，在任务完成或改变之后再重新组织。根据任务的不同，也许会有不同的人去承担管理层和协调角色，但都是根据任务的需求而定的，没有固定的头衔或者严格的层级。最出名的例子就是一家名为 Valve 的视频游戏公司。

- 层级有利于维持可预测性和可重复性。它简化了计划的制订，更容易自上而下控制一大帮人，这也是军事组织极其依赖这种方式的原因。但如果你是一家娱乐公司，在过去 10 年竭尽所能去招募地球上最聪明、最有创造力和最有天赋的人，却让他们坐在办公桌前并告知他们要做的东西，那就湮灭了他们 99% 的价值。我们要的是创新者，这意味着我们要维护一个任由他们挥洒的环境。 这就是 Valve 采取扁平化的原因。我们用这种方式直截了当地表达了我们没有任何管理，每个人都不需要向其他任何一个人报告。我们有创始人或主席，但他也不是你的经理。这个公司是由你们操控的——驶向机会，远离风险。你有权利为项目开绿灯，有权利发布产品。 ——Valve

- 在 Valve，员工们自行组织成为“小团队”，即各种多专业交叉的项目团队，而不是依赖于经理。如果人们认为一个项目的重要性值得参与，他们就会加入团队——而不是因为老板让他们必须加入。所有的办公桌都有轮子，他们可以按照自己挑选参与的项目定期移动办公桌，形成新的团队。这种方法使 Valve 获得了不可思议的成功，他们做出了史上卖得最好的四个 PC 游戏，2014 年被评为工作最让人满意的游戏公司，2011 年的估值达到 20 亿~40 亿美元，意味着如果按每个员工所赚得的钱来算，这家 400 人的公司已经超过了 Google 或 Apple。

- 扁平和分布式组织的优点是员工有更多的自主权和责任心，后文将会介绍，这些都是激励的基本要素。更多的自主权意味着最接近问题的人，也就是最了解问题的人，能够做出重要的决定，避免层级结构中大部分官僚主义带来的恶开销。不幸的是，分布式组织在公司领域的运用相对还比较少，所以不像管理驱动等级结构那样好理解和阐述。

- 彼得原理阐述了在层级组织中，每个员工都趋向于被提升到他们不能胜任的级别上，最终“每一个职位都将被一个不能胜任其工作的员工所占据”。其推理过程很简单：如果你在当前的角色中表现出色，最终会被提升到新的角色。终有一天，你也许会被提升到超过你能力的角色，无法表现得足以继续晋升，便困在这个无法胜任的角色中。 如果我们使用晋升作为奖赏，彼得原理就是必然的结果。为了避免这一结果的出现，我们需要做些额外的工作，比如只晋升那些已经在新角色上履职的员工，并实施培训计划帮助他们做得更好（阅读第 12 章了解更多信息）。然而，技术组织中彼得原则发生最常见的原因是将开发人员晋升为管理者。

- 许多软件公司相信，奖励开发人员的最佳方式就是将他们提升到管理层。问题是，管理岗通常并不是由技术岗逐级上升达到的，它是需要完全不同技能的一份工作。精通算法、架构和测试并不意味着你在安排工作的优先次序、进行复杂的人际关系谈判和培养人才方面也会做得很出色。在大多数情况下，你失去的是一位非凡的贡献者，但得到的却是一位平庸的经理，而且他十分可能会让其他个体贡献者的前进步伐也慢下来。 以管理作为晋升的最坏影响是向你的技术组织传递了这样一个信号：编写代码是二等工作。想把一家科技公司弄垮，最快的方法就是建立起这样的组织，只让没有经验和表现不好的开发人员去编写代码，而让所有有才能的熟练开发人员反过来做管理者的工作。我们无法通过管理获得好的代码，好的代码需要出色的开发人员来编写。 为了保证那些出色的开发人员能够继续编写代码，我们需要找到一种奖赏技术领导能力的方法——通过代码贡献在公司中赢得影响力，而不是依赖对人的管理。

- 在《创业维艰》一书中，Ben Horowitz 认为大多数创业公司最终将会出于两个原因而引入职位头衔。第一，因为其他大部分公司都在使用这些头衔，你的员工也需要一个头衔，以便他最后可以换工作。第二，职位头衔是“公司中角色描述的速写”，员工、客户和合作伙伴经常需要用这些头衔和公司打交道，特别是随着公司规模的扩大。尽管在大多数公司中，头衔都是一种标配，但少数公司甚至直接就把它取消了：CloudFlare 的 100 名员工都没有头衔，Valve 的 400 名员工也没有头衔，Zappos 正尝试取消 4000 名员工的头衔。

- 在 Paul Graham 的“杀死创业公司的 18 个错误”清单中，排名第一的就是单一创始人。为什么呢？因为创办一家公司的艰难是一个人难以承受的，它会带来巨大的压力、风险和艰辛的工作，除非身边有其他人一起分担，否则大多数人是无法独自应对的。你需要其他人来弥补你的弱点，对你的想法给出反馈，在你犯了错的时候为你鼓劲。

- 创业的低谷非常之深，几乎没有人可以独自承受这一切。如果有多名创始人，团队精神会使他们以看似违背能量守恒定律的方式凝聚在一起。每个人都认为“我不能让我的朋友失望”，这是人性中最强大的力量之一，在仅有一名创始人的情况下，他将失去这一力量。 ——Paul Graham，Y Combinator 联合创始人，硅谷创业教父，《黑客与画家》作者

- 两个创始人通常是通往成功的最好途径。你可以平均分配工作和股权，也没有政治操作的空间。三个创始人也没有问题：只是在职责划分上会更困难一些，但总可以通过投票决定。一旦超过了三人，事情会变得越来越不稳定，做出决定也变得更加困难，职责和股权的分配也更难处理，更有可能出现政治问题和内耗。

- 但我们也不能轻率挑选创业伙伴，因为你要和他们相处很长时间——成功的创业都是以 10 年为量级的（阅读 1.4.1 节了解更多信息）。你应该和可能的创业伙伴已经建立起了较长的、经过考验的关系，才有可能和他们一起开创公司。创业从某种程度上就像去打仗，如果你和创业伙伴已经在过去经历了战争的洗礼，你就知道以后也可以相互依靠，这是最好不过的。

- 这就是为什么原来的同事通常会成为最佳创业伙伴：如果你们之前已经一起成功地做了些事情，就更有可能再创辉煌。如果你以前和大学同学一起做过项目、一起学习、一起通宵熬夜，这样的人也是不错的选择。朋友和家人则可能是下一个最好的选择，但是可能会牵扯更多的风险

- 我们应当在创业伙伴身上寻找四种品质。第一，要找“敏思笃行”的人。要寻找你认识的那些不管有什么障碍都能克服的人。第二，要寻找具有互补技能的人。例如，如果你是程序员并善于开发产品，就要寻找能够处理好销售和市场推广，并善于发现客户的创业伙伴。第三，创业伙伴通常在年龄、经济状况和动机上应该是类似的。如果一个创始人寄希望于赚快钱，而另一个则对改变世界有长期的愿景，这是很难成功的。第四，也是最为重要的，就是你要找到能够信任的人。要建立信任，你必须了解合伙人的经历，所以也再次说明了为什么同事、同学和朋友是最合适的创业伙伴。

- 在急剧变化的时代，唯有学习者才能继承未来。不再学习的人通常只能全副武装地生活在不复存在的世界里。 ——Eric Hoffer，Reflections on The Human Condition

- 当然，你不必成为每一种技能的大师。我在这本书中已经提到过好多次，努力成为 T 型人是很好的思路，你不仅要深入掌握一个学科的知识并精通它，还要对其他学科也有广泛的涉猎并熟悉它们（阅读 2.1.2 节了解更多信息）。事实上，本书都是在讲如何建立多个学科间的知识，包括商业、设计、市场推广、软件工程、运维、培训和招聘。如果你读到了这里，你正在走向实现漂亮的 T 型人的道路上。

- 人们会想出各种借口解释自己为什么不学习新的东西，最常见的借口是他们太忙了，但实际上忙只是一个结论——做事情的时间不是找出来的，而是创造出来的。每当你听到自己说“我没有时间学习”的时候，就要意识到你其实是在说“我宁可把其他事情放在学习前面”。错过太多的学习机会是一种短视的行为，特别是在快速变化的软件行业。在这样的行业中，打造成功职业或成功公司的唯一方法就是不断让自己变得更加出色。

